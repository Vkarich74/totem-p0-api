import express from "express";
import cors from "cors";
import db from "./db.js";
import ownerRoutes from "./routes_owner/index.js";

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

// ===== HEALTH =====
app.get("/health", (_req, res) => res.json({ ok: true }));

// ===== ENSURE SALONS =====
async function ensureSalonsTable() {
  if (db.mode === "POSTGRES") {
    await db.run(`
      CREATE TABLE IF NOT EXISTS salons (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        slug TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'created',
        created_at TIMESTAMPTZ DEFAULT now(),
        updated_at TIMESTAMPTZ DEFAULT now()
      );
    `);
  } else {
    await db.run(`
      CREATE TABLE IF NOT EXISTS salons (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        slug TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'created',
        created_at TEXT DEFAULT (datetime('now')),
        updated_at TEXT DEFAULT (datetime('now'))
      );
    `);
  }
}

// ===== ENSURE OWNER_SALON (IDEMPOTENT MIGRATION) =====
async function ensureOwnerSalonTable() {
  if (db.mode !== "POSTGRES") {
    await db.run(`
      CREATE TABLE IF NOT EXISTS owner_salon (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        owner_id TEXT NOT NULL,
        salon_id INTEGER NOT NULL,
        status TEXT NOT NULL DEFAULT 'active',
        created_at TEXT DEFAULT (datetime('now'))
      );
    `);
    await db.run(`
      CREATE UNIQUE INDEX IF NOT EXISTS ux_owner_salon
      ON owner_salon (owner_id, salon_id);
    `);
    return;
  }

  // Проверяем, существует ли колонка salon_id
  const col = await db.get(`
    SELECT data_type
    FROM information_schema.columns
    WHERE table_name = 'owner_salon'
      AND column_name = 'salon_id'
  `);

  // Таблицы нет — создаём сразу корректную
  if (!col) {
    await db.run(`
      CREATE TABLE owner_salon (
        id BIGSERIAL PRIMARY KEY,
        owner_id TEXT NOT NULL,
        salon_id BIGINT NOT NULL,
        status TEXT NOT NULL DEFAULT 'active',
        created_at TIMESTAMPTZ DEFAULT now()
      );
    `);
    await db.run(`
      CREATE UNIQUE INDEX ux_owner_salon
      ON owner_salon (owner_id, salon_id);
    `);
    return;
  }

  // Тип уже правильный — выходим
  if (col.data_type === "bigint") {
    return;
  }

  // === МИГРАЦИЯ TEXT -> BIGINT ===
  console.log("[MIGRATION] owner_salon.salon_id TEXT -> BIGINT");

  await db.run(`DROP TABLE IF EXISTS owner_salon_new;`);

  await db.run(`
    CREATE TABLE owner_salon_new (
      id BIGSERIAL PRIMARY KEY,
      owner_id TEXT NOT NULL,
      salon_id BIGINT NOT NULL,
      status TEXT NOT NULL DEFAULT 'active',
      created_at TIMESTAMPTZ DEFAULT now()
    );
  `);

  await db.run(`
    INSERT INTO owner_salon_new (owner_id, salon_id, status, created_at)
    SELECT owner_id, salon_id::BIGINT, status, created_at
    FROM owner_salon;
  `);

  await db.run(`DROP TABLE owner_salon;`);
  await db.run(`ALTER TABLE owner_salon_new RENAME TO owner_salon;`);

  await db.run(`
    CREATE UNIQUE INDEX ux_owner_salon
    ON owner_salon (owner_id, salon_id);
  `);

  console.log("[MIGRATION] owner_salon FIXED");
}

// ===== ENSURE FINANCE =====
async function ensureFinanceTable() {
  if (db.mode === "POSTGRES") {
    await db.run(`
      CREATE TABLE IF NOT EXISTS finance_events (
        id BIGSERIAL PRIMARY KEY,
        salon_id BIGINT NOT NULL,
        master_id TEXT,
        type TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        amount INTEGER NOT NULL,
        currency TEXT NOT NULL DEFAULT 'KGS',
        created_at TIMESTAMPTZ DEFAULT now()
      );
    `);
  } else {
    await db.run(`
      CREATE TABLE IF NOT EXISTS finance_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        salon_id INTEGER NOT NULL,
        master_id TEXT,
        type TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        amount INTEGER NOT NULL,
        currency TEXT NOT NULL DEFAULT 'KGS',
        created_at TEXT DEFAULT (datetime('now'))
      );
    `);
  }
}

// ===== ENSURE SUBSCRIPTIONS =====
async function ensureSubscriptionsTable() {
  if (db.mode === "POSTGRES") {
    await db.run(`
      CREATE TABLE IF NOT EXISTS salon_subscriptions (
        salon_id BIGINT PRIMARY KEY,
        active_until TIMESTAMPTZ NOT NULL
      );
    `);
  } else {
    await db.run(`
      CREATE TABLE IF NOT EXISTS salon_subscriptions (
        salon_id INTEGER PRIMARY KEY,
        active_until TEXT NOT NULL
      );
    `);
  }
}

// ===== ACTIVATION GUARD =====
async function requireActiveSalon(req, res, next) {
  const salon_id =
    req.headers["x-salon-id"] ||
    req.body?.salon_id ||
    req.params?.salon_id;

  if (!salon_id) {
    return res.status(400).json({ error: "SALON_ID_REQUIRED" });
  }

  const sql =
    db.mode === "POSTGRES"
      ? `SELECT 1 FROM salon_subscriptions
         WHERE salon_id=$1 AND active_until >= NOW()`
      : `SELECT 1 FROM salon_subscriptions
         WHERE salon_id=? AND active_until >= datetime('now')`;

  const row = await db.get(sql, [Number(salon_id)]);
  if (!row) {
    return res.status(403).json({ error: "SALON_NOT_ACTIVE" });
  }

  next();
}

// ===== PUBLIC SALON RESOLVE =====
app.use("/s/:slug", async (req, _res, next) => {
  const slug = req.params.slug;

  const select =
    db.mode === "POSTGRES"
      ? "SELECT * FROM salons WHERE slug=$1"
      : "SELECT * FROM salons WHERE slug=?";

  let salon = await db.get(select, [slug]);

  if (!salon) {
    const insert =
      db.mode === "POSTGRES"
        ? `INSERT INTO salons (slug,name,status)
           VALUES ($1,$2,'created')
           ON CONFLICT (slug) DO NOTHING
           RETURNING *`
        : `INSERT OR IGNORE INTO salons (slug,name,status)
           VALUES (?,?, 'created')`;

    if (db.mode === "POSTGRES") salon = await db.get(insert, [slug, slug]);
    else {
      await db.run(insert, [slug, slug]);
      salon = await db.get(select, [slug]);
    }
  }

  req.salon = salon;
  req.salon_id = salon.id;
  next();
});

app.get("/s/:slug/resolve", (req, res) => {
  res.json({
    ok: true,
    salon_id: String(req.salon_id),
    slug: req.salon.slug,
    status: req.salon.status
  });
});

// ===== OWNER API =====
app.use("/owner", requireActiveSalon, ownerRoutes);

// ===== FINANCE READ =====
app.get("/finance/salon/:salon_id", requireActiveSalon, async (req, res) => {
  const sql =
    db.mode === "POSTGRES"
      ? `SELECT * FROM finance_events WHERE salon_id=$1 ORDER BY created_at DESC`
      : `SELECT * FROM finance_events WHERE salon_id=? ORDER BY created_at DESC`;

  const rows = await db.all(sql, [Number(req.params.salon_id)]);
  res.json({ ok: true, items: rows });
});

// ===== PAYMENT =====
app.post("/finance/event", async (req, res) => {
  const { salon_id, type, amount } = req.body;
  if (!salon_id || !type || !amount) {
    return res.status(400).json({ error: "INVALID_INPUT" });
  }

  await db.run(
    db.mode === "POSTGRES"
      ? `INSERT INTO finance_events (salon_id,type,amount,status)
         VALUES ($1,$2,$3,'confirmed')`
      : `INSERT INTO finance_events (salon_id,type,amount,status)
         VALUES (?,?,?,'confirmed')`,
    [Number(salon_id), type, amount]
  );

  await db.run(
    db.mode === "POSTGRES"
      ? `
        INSERT INTO salon_subscriptions (salon_id, active_until)
        VALUES ($1, NOW() + INTERVAL '30 days')
        ON CONFLICT (salon_id)
        DO UPDATE SET active_until =
          GREATEST(salon_subscriptions.active_until, NOW())
          + INTERVAL '30 days'
      `
      : `
        INSERT INTO salon_subscriptions (salon_id, active_until)
        VALUES (?, datetime('now','+30 days'))
        ON CONFLICT(salon_id)
        DO UPDATE SET active_until =
          datetime(MAX(active_until, datetime('now')), '+30 days')
      `,
    [Number(salon_id)]
  );

  res.json({ ok: true });
});

// ===== START =====
async function bootstrap() {
  await ensureSalonsTable();
  await ensureOwnerSalonTable();
  await ensureFinanceTable();
  await ensureSubscriptionsTable();

  app.listen(PORT, () => {
    console.log("TOTEM API STARTED", PORT);
  });
}

bootstrap().catch((e) => {
  console.error(e);
  process.exit(1);
});
